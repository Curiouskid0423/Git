# Gitlet Design Spec

**CS61B Spring 20, Final Project -- Gitlet**
**Name:** Kevin Li

<hr>

## Directory Tree:
*   **Note** :  `Repo` is not serialized, and never explicitly constructed in code. Instead, use `Repo.getRepo`.
``` Markdown
** Working Directory ** 

`.gitlet`
    - HEAD
    - objects
        -- commits (dir)
        -- blobs (dir)
        -- ** CommitTree (file) would also be saved here.
    - refs
        -- branches (dir)
        -- remotes (dir)
    - stage
```

## Classes and Data Structures
*   **Repo** : A class that contains `CommitTree` and `Stage`. Not serialized.
    - `Repo.getRepo()` : Factory method for obtaining a repo (pass in `True`), or constructing a repo (pass in `False`) .
    - Contains all the methods except `init()`, which would be in Main.class.
    - `LOG` :  ~~Contain the current log message.~~ No need, just print in timely order.
<br>

*   **CommitTree** :  A serialized class         
    - `_roots` : A pointer to root commit when called on constructor.
    - `branches` : A `HashMap <String, String>` that maps branch name to a commit hash id.
    - `HEAD` :  A universal current pointer read from `.gitlet/HEAD` file, which contains just one line `.gitlet/refs/<active branch>`.
<br>

*   **Stage** :  A serialized class         
    - `addition` : Addition stage has type `HashMap <String, String>`, which maps the file name to the Blob id (hashed).
    - `removal` : Removal stage has type `HashMap <String, String>`. Mapping same as addition stage.

*   **Commit** :  A commit object contains: 
    - `parent` of type Commit.
    - `mergeParent` of type Commit. Set to null by default unless was merged.
    - `timestamp` : Save in **Date.currentTimeMillis**, and leave the processing to later `log`
    - `blobMap` of type `HashMap <String, String>` which maps the filename to its Blob hash-id.
     Each commit has a unique mapping of blobs upon its creation. Since every commit is created by cloning its parent, each time a `Commit` is created, we process the `Stage` from `CommitTree`, reconstruct the `blobMap` based on staged content. 
    - `uid` of type String. UID is generated by `Utils.sha1()` once, and then stored in `uid` attribute. The attribute is hashed by concatenating the "string" of all content in the commit such that the content will always be the same (i.e. content-specific.)
<br>

*   **Blob** : A blob object contains `hashID`, `filename` and `content`, all of which have a type of String.
HashID should **re-generate** if the content is ever changed (as of now, the plan is to never change the blob after its creation).

<hr>

## Algorithms

###### Note: Write error-handling / condition-check into reusable helper functions!

*   **`init`** 
``` Markdown
`Init()` contains two part: creating the directory, and instantiate a repo. 

0. Validate arguments
1. Check whether a .gitlet dir is presented. If yes, call an error message and don't overwrite.
2. Init the directory
3. Instantiate a `Repo`, which will then instantiate a `CommitTree` and a `Stage`
4. A `CommitTree` constructor makes an initial commit. The `Commit` and `CommitTree` constructor should initialize the rest of the variables.
5. Serialize: write the initial commit to master branch file.
6. Runtime: ** Constant **
```
            

*   **`add`** : Gitlet restrict `add()` to adding one file.
``` Markdown

0. Validate argument # and is gitlet directory.
1. Process `args[1]` filename and search for the file in CWD. If the file does not exist, prompt an error.
2. Read the file, create a `Blob` of it, and then save the blob in /blobs directory with a filename of hashed blob.
3. Add the Blob to Addition Stage (store the filename as key, and hashID as value), which will be serialized.
4. If that filename exists in the stage, just overwrite the previous entry.
5. If the CWD version of the file is entirely the same to the `HEAD` commit, do
not stage, and remove that `filename` from the stage if it is already staged.
6. Serialize the stage.
```
            
*   **`commit`** :   **Double check before moving on!**
``` Markdown
-- Commits only care about files in the `stage` and have nothing to do with current CWD.

0. Validate argument # and is gitlet directory. `Read things in.`
1. Clone the parent commit. Change parent to new parent. 
2. Advance active branch head (for `HEAD` file no need to reassign since it points to `/<active_branch>`).
3. Update the remaining attributes in Commit. As for `blobMap`.
4. For files in addition stage: If the filename is not present in recorded `blobMap`, add it to the HashMap.
5. (continue) If the filename is present, but blob-id modified, map the filename to the new version.
6. For files in removal stage: If the filename is not present in `blobMap`, -rm has handled this error already.
If the filename is present, remove the item from our HashMap.
7. Clear the stages at the end.
```

*   **`rm`**
```Markdown
0. Validation, and then process `args[1]`.
1. If the file is staged, unstage it.
2. If the file is not stage, and the `HEAD` commit is tracking it, stage it for removal,
and remove the file is the user hasn't done so (restrictedDelete).
3. If the file is neither staged nor tracked, print Error "No reason to remove the file."
```

*   **`log`**
```Markdown
0. Validation.
1. Construct the log based on the original Spec on CS61b web.
3. Show time in local time zone.
4. Log history ignores other branches and the future. Basically just trace back from the current HEAD.
```
*   **`global-log`**
```Markdown
0. Validation.
1. Same as log but display all information of all commits. The order does not matter.
```

*   **`find`**
```Markdown
0. Validation.
1. Print out all the ids that has the `args[1]` commit message.
2. Print ids in separate line if there are multiple of them.
3. If no such commit exists, prints the error message "Found no commit with that message."
```

*   **`status`**
```Markdown
0. Validation.
1. Print out all the branches, and put `*` in front of the current branch.
2. Print as the spec said.
3. `Untracked` includes files that have been staged for removal,
but then re-created without Gitlet's knowledge
4. ** Runtime **: 
Make sure this depends only on the amount of data in CWD, plus the number of files 
staged to be added or deleted plus the number of branches.
```

*   **`checkout`** : **Double check before moving on!**
```Markdown
[X] Implement `abbreviated id`! 
Abbreviation also comes out in `reset`, so best if you have a helper function.
Basically check if the given string matches the charcters at the beginning of the string.

0. Validation.
1. Identify cases. For every case, clear the stage at the end.
    a. java gitlet.Main checkout -- [file name]
    b. java gitlet.Main checkout [commit id] -- [file name]
    c. java gitlet.Main checkout [branch name]
2. For case `a`, take the version of the file with that name, and overwrite the one in CWD currently. 
If the file does not exist in HEAD commit, cast an error. If the file is deleted in CWD already, add the file to CWD anew.

3. For case `b`, same as `a` but this time find the version with that name in the specified commit.
If the file does not exist in the given commit, print error. Or if no such commit id exist, also error.

4. For case `c`, overwrite the CWD with files in the HEAD commit of the given branch.

5. (continue) If the checkout branch is current branch, print error: "No need to checkout the current branch."
Or if the branch does not exist, print error as well. 
6. (continue) If checkout successful, HEAD will now point to the checkout branch. 
Any file tracked in the previous/current branch but not presented in checkout branch, will be deleted. 
7. If a working file is `untracked` and would be overridden, print error and exit. 
Check this before even checking out.

8. Lastly, clear the stage.
```

*   **`branch`** :  **Double check before moving on!**
```Markdown

0. Validation.
1. In `CommitTree`, add a new branch to _branches.
2. Create a new branch by making a new file with that branch name.
3. The file should contain the uid of HEAD commit.
4. If the branch name exists, print " A branch with that name already exists."
```
*   **`rm-branch`** 
```Markdown
0. Validation.
1. Safely delete the branch file in /refs/branches, 
2. Remove from the name from the `CommitTree` ArrayList.
```
*   **`reset`** : Essentially `checkout` that also changes the current branch head.
```Markdown
-- `java gitlet.Main reset [commit id]`
-- **The Description below is erroneous and would be corrected soon.**

0. Validation. Check if such ID exists
1. Checkout ALL files by the given commit id. 
2. Remove tracked files if they are not present in the given commit. (Don't touch untracked files.)
3. Move the `current branch head` to given commit. (Not HEAD! HEAD is moved already in `checkout`)
4. Renew the staging area.
5. If an untracked file is could be overwritten by the given commit (i.e. present in that commit), print an error.
But if an untracked file is not present in the given commit, just ignore it (don't need to do anything in this case).

```

*   **`merge`**
```Markdown

> Compare the files UNION of merge-head and current-head, to LCA. 
> (Runtime for this step should be `O(Merge + Curr)`)

**Steps**

0.  Validation.
1.  Error handling.
2.  Find the closest LCA of `current`, store it (a Commit), and then get its blobsMap.
    - (1) If `M` is LCA, merge complete, do nothing.
    - (2) If `C` is LCA, checkout `M` and print message "fast-forwarded".
3.  Make a union keyset with M's and C's blobMap.

4.  Traverse over the `Union Keyset`.
(for the sake of simplicity: `M` = merge branch head, `C` = current)   

4a. For each file, determine its case. First check `present or not` in (M, C).
    - If (M, C) = (P, P) means that both branch presents the file. 
        - If LCA doesn't have it --> If M content != C, merge conflicts.
        - If LCA has it --> Check change.
    - (M, C) = (NP, P) 
        - If LCA doesn't have it --> do nothing.
        - If LCA has it --> Is C changed? If yes, conflict. If not, removed (and untracked) (Gitlet rm <file>)
    - (M, C) = (P, NP) 
        - If LCA doesn't have it --> Checkout that file, write into CWD, and stage it.
        - If LCA has it --> Is M changed? If yes, conflict. If not, do nothing st C remain absent. 
    - (M, C) = (NP, NP) It's basically not tracked. Do nothing.
4b. Check if the file is `changed` comparing with LCA:   
    - Not changed in C, not changed in M:  Do nothing.
    - Not changed in C, changed in M:  Checkout the file in M (overwrite). Stage that for commit.
    - Changed in C, not changed in M:  Do nothing.
    - Changed in C, changed in M, but in the same way: Do nothing (no conflict)
    - Changed in C, changed in M, but conflicts.
4c. There are 4 conflict cases listed above, and here's what to do:
First, print in terminal "Encountered a merge conflict." Then, get C's 
file (CWD file), and replace with the following.Treat a deleted file in a branch as an empty file.
    
<<<<<<< HEAD
contents of file in current branch
=======
contents of file in given branch
>>>>>>>

5. Commit (mergeParent not null, commit msg = `Merged [given branch name] into [current branch name]`).

P.S. `LCA` = Latest common ancestor.
```

<hr>

## Commands
*   `init `
*   `add`
*   `commit`
*   `rm`
*   `log`
*   `global-log`
*   `find`
*   `status`
*   `checkout`
*   `branch`
*   `rm-branch`
*   `reset`
*   `merge`
*   `list-remote`
##### Extra credit 
*   `add-remote`
*   `rm-remote`
*   `push`
*   `fetch`
*   `pull`

<hr>


## Persistence Guidance

*   How do you get around excessive pointer problem with serialization?
*   How to retrieve small part of info quickly?
    i.e `DO NOT` serialize the entire CommitTree
*   Get familiar with the concept of `lazy loading and caching`.

<hr>

## Notes on Remote

*   A remote repository is **not** a user-editable repository. It is only
    a .gitlet directory and does not have a CWD -- you cannot make 
    changes directly to a remote and add or commit things. You can only 
    `push to` or `pull from` a remote!
<hr>   

## Thoughts on Future Improvement:

*   Scream for `merge conflict`, if encountered, and show the location of conflict before merging.
*   Rewrite some commands in `Utils.java` and remove unnecessary comments in it before pushing gitlet to your Github.
*   Print message on what is commited when command `gitlet commit` is called, which is essentially what git does.
*   Implement the **bins** in `/refs/commits/` for faster access to commits.
*   Improve Gitlet with more commands that **Git** actually has, such as `git rebase`.
*   Try to go "broad" but not necessarily all the features of an command in git. (You're not going into production anyways.)
*   File separator !!! EDIT: This is implemented Yay :)
#### What Gitlet currently simplifies from Git:
1.  Incorporating trees into commits and not dealing with `subdirectories` 
    (so there will be one "flat" directory of plain files for each repository).
2.  Limiting ourselves to merges that reference two `parents` (in real Git, there c
    an be any number of parents.)
3.  Having our `metadata` consist only of a timestamp and log message. A commit, 
    therefore, will consist of a log message, timestamp, a mapping of file names to 
    blob references, a parent reference, and (for merges) a second parent reference.
